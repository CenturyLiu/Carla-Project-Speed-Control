#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Jun 15 09:21:45 2020

@author: shijiliu
"""


#!/usr/bin/env python

# Copyright (c) 2019 Computer Vision Center (CVC) at the Universitat Autonoma de
# Barcelona (UAB).
#
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.

import glob
import os
import sys

try:
    sys.path.append(glob.glob('../carla/dist/carla-*%d.%d-%s.egg' % (
        sys.version_info.major,
        sys.version_info.minor,
        'win-amd64' if os.name == 'nt' else 'linux-x86_64'))[0])
except IndexError:
    pass

import carla
import math
import random
import time

from carla_env import CARLA_ENV # self-written class that provides help functions, should be in the same folder

# color for debugging
red = carla.Color(255, 0, 0)
green = carla.Color(0, 255, 0)
blue = carla.Color(47, 210, 231)
cyan = carla.Color(0, 255, 255)
yellow = carla.Color(255, 255, 0)
orange = carla.Color(255, 162, 0)
white = carla.Color(255, 255, 255)

# enable/disable debug mode to draw the trajectory finding process in carla
DEBUG = True
display_trajectory = True


def get_next_w(current_w, waypoint_separation):
    '''
    code adapted from "lane_explorer.py" available in carla-simulator/PythonAPI/util

    Parameters
    ----------
    current_w : carla.Waypoint() 
        the source point.

    Returns
    -------
    potential_w : carla.Waypoint() 
        potential way point that can be connected by the current waypoint

    '''
    # list of potential next waypoints
    potential_w = list(current_w.next(waypoint_separation))

    # list of potential waypoints in opposite direction
    potential_w += list(current_w.previous(waypoint_separation))

    '''
    # check for available right driving lanes
    
    if current_w.lane_change & carla.LaneChange.Right:
        right_w = current_w.get_right_lane()
        if right_w and right_w.lane_type == carla.LaneType.Driving:
            potential_w += list(right_w.next(waypoint_separation))

    # check for available left driving lanes
    if current_w.lane_change & carla.LaneChange.Left:
        left_w = current_w.get_left_lane()
        if left_w and left_w.lane_type == carla.LaneType.Driving:
            potential_w += list(left_w.next(waypoint_separation))
    '''
    return potential_w
    
def end_of_search(current_w, destination, waypoint_separation):
    '''
    

    Parameters
    ----------
    current_w : carla.Waypoint()
        the current waypoint .
    destination : carla.Waypoint()
        the destination we want to reach. 
    waypoint_separation : float
        distance between the way points.

    Returns
    -------
    Boolean value indicating whether the current waypoint is close enough to the destination

    '''

    current_location = current_w.transform.location
    destination_location = destination.transform.location
    distance = math.sqrt( (current_location.x - destination_location.x)**2 + (current_location.y - destination_location.x)**2 )
    if distance <= waypoint_separation / 10:
        return True
    else:
        return False
    
    
def generate_path(env, start, destination, waypoint_separation = 4):
    '''
    Apply Dijkstra's algorithm to find the path connecting the start point and destination point with smallest
    number of autogenerated waypoints involved.
    
    Note: there is no guarantee the find path is the shortest path between the start and destination, but the
          path should approximately be the shortest.
    

    Parameters
    ----------
    start : carla.Waypoint()
        the start point of a path.
    destination : carla.Waypoint()
        the destination we want to reach. 
        Note: the search will stop once we reach a point within "waypoint_separation" away from the destination
    waypoint_separation : float
        distance between the way points.
    Returns
    -------
    trajectory : list of 2d points
        a trajectory that can be used for interpolation and vehicle control.

    '''
    trajectory = [] # the trajectory we will return
    
    explored_w_list = [] # store waypoints that have been explored
    explored_w_traceback_index = [] # each explored point was arrived by a previous point, 
                                    # store the index of the previous point for traceback
    
    potential_w_list = [] # store the waypoints to be explored
    potential_w_traceback_index = [] # each potential point was arrived by a previous point, 
                                     # store the index of the previous point for traceback 
    
    # initialization
    potential_w_list.append(start)
    potential_w_traceback_index.append(-1)
    index = 0 # index that will be stored into the 2 index list
    
    # main loop for exploration
    while True:
        current_w = potential_w_list.pop(0) # get the first element of the list
        current_w_index = potential_w_traceback_index.pop(0) # get the traceback index of the current waypoint
        
        # DEBUG
        if DEBUG:
            env.world.debug.draw_point(current_w.transform.location, size = 0.15, color = green, life_time = 2.0)
        
        
        # check whether we have arrived at the destination
        if end_of_search(current_w, destination, waypoint_separation):
            # trace back
            while True:
                if current_w_index == -1: # reach the start point
                    break
                location = current_w.transform.location
                trajectory.insert(0,(location.x,location.y))
                current_w = explored_w_list[current_w_index]
                current_w_index = explored_w_traceback_index[current_w_index]
            
            print("find a path with " + str(len(trajectory)) + " waypoints")
            
            if display_trajectory:
                for point in trajectory:
                    loc = carla.Location(x = point[0], y = point[1], z = 0.0)
                    env.world.debug.draw_point(loc, size = 0.15, color = green, life_time=0.0, persistent_lines=True)
            break
        
        # add the point to explored list
        explored_w_list.append(current_w)
        explored_w_traceback_index.append(current_w_index)
        
        # DEBUG
        if DEBUG:
            env.world.debug.draw_point(current_w.transform.location, size = 0.1, color = red, life_time=10.0)
        
        # we haven't reach the end, search based on the current waypoint
        potential_w = get_next_w(current_w, waypoint_separation) # get potential waypoint that can be connected by this point
        
        # check whether the potential point has not been connected
        for pt in potential_w:
            if not pt in potential_w_list and not pt in explored_w_list: # this point has not been explored
                potential_w_list.append(pt)
                potential_w_traceback_index.append(index)
                
                if DEBUG:
                    env.world.debug.draw_point(current_w.transform.location, size = 0.08, color = white, life_time= 2.0)
                
        if len(potential_w_list) == 0: # no more potential points
            print("failed to find the trajectory")
            break
        
        index += 1    
        
    return trajectory
    
def main():
    try:
        client = carla.Client("localhost",2000)
        client.set_timeout(10.0)
        world = client.load_world('Town06')

        # set the weather
        world = client.get_world()
        weather = carla.WeatherParameters(
            cloudiness=10.0,
            precipitation=0.0,
            sun_altitude_angle=90.0)
        world.set_weather(weather)

        # set the spectator position for demo purpose
        spectator = world.get_spectator()
        spectator.set_transform(carla.Transform(carla.Location(x=-68.29, y=151.75, z=170.8), carla.Rotation(pitch=-31.07, yaw= -90.868, roll=1.595))) # plain ground

        env = CARLA_ENV(world)
        time.sleep(2)

        # get map
        carla_map = env.world.get_map()

        start_raw = carla.Location(x=-277.08, y=-15.39, z=4.94)
        destination_raw = carla.Location(x=-9.0, y=-50.0, z=0.0)
        start = carla_map.get_waypoint(start_raw)
        destination = carla_map.get_waypoint(destination_raw)
        
        trajectory = generate_path(env,start, destination, waypoint_separation = 50)
        
    finally:
        return trajectory

if __name__ == '__main__':
    try:
        trajectory = main()
    except KeyboardInterrupt:
        print('\nExit by user.')
    finally:
        print('\nExit.')
    